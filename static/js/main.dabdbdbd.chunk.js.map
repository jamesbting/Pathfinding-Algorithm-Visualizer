{"version":3,"sources":["Components/InformationBox/InformationBox.jsx","Components/StaticNode/StaticNode.jsx","Components/InformationBar/InformationBar.jsx","Algorithms/AbstractAlgorithm.js","Algorithms/Dijkstra.js","DataStructures/Heap.js","Algorithms/ASearch.js","DataStructures/Stack.js","Algorithms/DepthFirstSearchIterative.js","Algorithms/DepthFirstSearchRecursive.js","Algorithms/BreadthFirstSearch.js","Components/AlgorithmMenu/AlgorithmMenu.jsx","Components/SpeedMenu/SpeedMenu.jsx","Components/ButtonBox/ButtonBox.jsx","Components/Node/Node.jsx","Components/Grid/Grid.jsx","Components/TopBar/TopBar.jsx","Components/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["InformationBox","props","className","informationType","text","childComponent","StaticNode","isFinish","isStart","isWall","isPath","isVisited","extraClassName","InformationBar","createInformationBox","type","AbstractAlgorithm","name","description","link","this","visitedNodesInOrder","path","grid","startNode","finishNode","Dijkstra","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","getNodesInShortestPathOrder","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes","nodesInShortestPathOrder","currentNode","unshift","Heap","heap","current","nodeComparator","Math","floor","next","curr","smallest","splice","temp","leftChildIndex","rightChildIndex","leftChild","rightChild","f","includes","key","find","element","equals","size","ASearch","currGrid","getGrid","openList","g","pop","closed","parent","reverse","children","getNeighbors","i","child","h","ManhattanHeuristic","includesElement","findElement","array","lastNode","abs","newGrid","newRow","Stack","data","top","isEmpty","DepthFirstSearchIterative","stack","visitNode","u","buildPath","w","DepthFirstSearchRecursive","traverse","BreadthFirstSearch","queue","AlgorithmMenu","algorithms","options","getAlgorithmName","useStyles","makeStyles","theme","root","margin","spacing","React","useState","anchorEl","setAnchorEl","selectedIndex","setSelectedIndex","classes","List","component","aria-label","ListItem","button","aria-haspopup","aria-controls","onClick","event","currentTarget","variant","color","ListItemText","primary","secondary","Menu","id","keepMounted","open","Boolean","onClose","map","option","index","MenuItem","selected","algorithm","changeAlgorithm","handler","handleSelect","backgroundColor","palette","main","common","white","SpeedMenu","newSpeed","handleMenuItemClick","ButtonBox","Toolbar","algorithmChangeHandler","title","Button","clickChild","speedChangeHandler","Node","onMouseDown","onMouseEnter","onMouseUp","PATH_SPEEDS","VISITED_SPEEDS","Grid","state","rows","cols","mouseIsPressed","currentSpeed","visualizeAlgorithm","bind","getNewGridWithWallToggled","setState","setTimeout","animateShortestPath","document","getElementById","solve","getPath","getVisitedNodesInOrder","animateAlgorithm","getInitialGrid","speed","setClick","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","rebuildGrid","Component","currentRow","createNode","slice","newNode","flexGrow","menuButton","marginRight","HideOnScroll","window","trigger","useScrollTrigger","target","Slide","appear","direction","in","TopBar","AppBar","position","Typography","PathfindingVisualizer","changeSpeed","generator","getAlgorithmDescription","href","getLink","rel","click","console","log","newAlgorithm","App","Helmet","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.dabdbdbd.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nimport \"./InformationBox.css\";\r\n\r\n// class that represents the box that wraps the pictorial representations of the different types of nodes\r\nexport default function InformationBox(props) {\r\n  return (\r\n    <div className={`information information--${props.informationType}`}>\r\n      <>\r\n        {props.text}\r\n        {props.childComponent}\r\n      </>\r\n    </div>\r\n  );\r\n}\r\n","import React from \"react\";\r\n\r\nimport \"../Node/Node.css\";\r\n/// class that represents a static node, that is used with the information box, to depict the different types of nodes\r\nexport default function StaticNode(props) {\r\n  const { isFinish, isStart, isWall, isPath, isVisited } = props;\r\n  //ternary that create an extra classname for CSS coloring.\r\n  const extraClassName = isFinish\r\n    ? \"node-finish\"\r\n    : isStart\r\n    ? \"node-start\"\r\n    : isWall\r\n    ? \"node-wall\"\r\n    : isPath\r\n    ? \"node-shortest-path\"\r\n    : isVisited\r\n    ? \"node-visited\"\r\n    : \"\";\r\n\r\n  return <div className={`node ${extraClassName}`}></div>;\r\n}\r\n","import React from \"react\";\r\nimport InformationBox from \"../InformationBox/InformationBox\";\r\nimport StaticNode from \"../StaticNode/StaticNode\";\r\n\r\nimport \"./InformationBar.css\";\r\n\r\n//class that represents the top portion above the grid, and is an container for the static node classes\r\nexport default function InformationBar(props) {\r\n  const createInformationBox = (type) => {\r\n    const isStart = type === \"Start\";\r\n    const isFinish = type === \"Finish\";\r\n    const isWall = type === \"Wall\";\r\n    const isPath = type === \"Path\";\r\n    const isVisited = type === \"Visited\";\r\n    return (\r\n      <InformationBox\r\n        informationType={`${type}-node`}\r\n        text={`${type} node `}\r\n        childComponent={\r\n          <StaticNode\r\n            isStart={isStart}\r\n            isFinish={isFinish}\r\n            isWall={isWall}\r\n            isPath={isPath}\r\n            isVisited={isVisited}\r\n          ></StaticNode>\r\n        }\r\n      ></InformationBox>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"nodeInformationBox\">\r\n        {props.text}\r\n        <div>\r\n          {createInformationBox(\"Start\")}\r\n          {createInformationBox(\"Finish\")}\r\n          {createInformationBox(\"Wall\")}\r\n          {createInformationBox(\"Path\")}\r\n          {createInformationBox(\"Visited\")}\r\n          {createInformationBox(\"Regular\")}\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","//Abstract class that should be an extended for the making the algorithm\r\n//Should not be instantiated\r\n//each concrete extension of this class should have 4 attributes\r\n//1) name : the name of the algorithm\r\n//2) description: a short sentence or 2 that describes the algorithm\r\n//3) path: an array of nodes that represents the last solved path\r\n//4) visitedNodesInOrder: an array of nodes that represents the last set of nodes that were visited, in the order that they were visited\r\n//5) link: a link to an explanation of each algorithm\r\n// these attributes are used for displaying information about the algorithm\r\n\r\nexport class AbstractAlgorithm {\r\n  // function that takes as input a grid, as well as the start and end node, which\r\n  constructor(name, description, link) {\r\n    this.name = name;\r\n    this.description = description;\r\n    this.link = link;\r\n    this.visitedNodesInOrder = [];\r\n    this.path = [];\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {}\r\n\r\n  //some getter methods\r\n  getPath() {\r\n    return this.path;\r\n  }\r\n\r\n  getAlgorithmDescription() {\r\n    return this.description;\r\n  }\r\n\r\n  getAlgorithmName() {\r\n    return this.name;\r\n  }\r\n\r\n  getVisitedNodesInOrder() {\r\n    return this.visitedNodesInOrder;\r\n  }\r\n\r\n  getLink() {\r\n    return this.link;\r\n  }\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nimport { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\n\r\n//can improve the speed by using a min heap\r\nexport default class Dijkstra extends AbstractAlgorithm {\r\n  constructor() {\r\n    const description =\r\n      \"Dijkstra's Algorithm is a greedy algorithm that finds the shortest path between 2 nodes. For a given source node in the graph, the algorithm finds the shortest path between the current node and every other node. While simple and viable, it is possible to improve on it's performance with algorithms such as A * Search.\";\r\n    const name = \"Dijkstra's Algorithm\";\r\n    const link = \"https://youtu.be/GazC3A4OQTE\";\r\n    super(name, description, link);\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = this.getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n      //while there are unvisitedNodes in the queue,\r\n\r\n      this.sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall) continue;\r\n\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) {\r\n        this.visitedNodesInOrder = visitedNodesInOrder;\r\n        this.getNodesInShortestPathOrder(finishNode);\r\n        return true;\r\n      }\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) {\r\n        this.visitedNodesInOrder = visitedNodesInOrder;\r\n        this.getNodesInShortestPathOrder(finishNode);\r\n        return true;\r\n      }\r\n      this.updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n\r\n  //takes a list of nodes and sorts them by their distance from the start node in ascending order\r\n  sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n\r\n  updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = this.getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n\r\n  getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n\r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the solve method above.\r\n  //updates the path attribute\r\n  getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    this.path = nodesInShortestPathOrder;\r\n  }\r\n}\r\n","//this class represents a min heap\r\n//TODO: Fix the heap so that it works\r\nexport default class Heap {\r\n  constructor() {\r\n    this.heap = [null]; // dummy element at index 0\r\n  }\r\n\r\n  get() {\r\n    return this.heap[1];\r\n  }\r\n\r\n  push(node) {\r\n    //push it to the end of the node\r\n    this.heap.push(node);\r\n    if (this.heap.length > 1) {\r\n      let current = this.heap.length - 1;\r\n\r\n      //upheap the node to its correct position\r\n      while (\r\n        current > 1 &&\r\n        this.nodeComparator(\r\n          this.heap[Math.floor(current / 2)],\r\n          this.heap[current]\r\n        ) > 0\r\n      ) {\r\n        let next = this.heap[Math.floor(current / 2)];\r\n        let curr = this.heap[current];\r\n        this.heap[current] = next;\r\n        this.heap[Math.floor(current / 2)] = curr;\r\n        current = Math.floor(current / 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  pop() {\r\n    let smallest = this.heap[1];\r\n\r\n    if (this.heap.length > 2) {\r\n      this.heap[1] = this.heap[this.heap.length - 1];\r\n      this.heap.splice(this.heap.length - 1);\r\n\r\n      //down heap the element to its correct position\r\n      if (this.heap.length === 3) {\r\n        if (this.nodeComparator(this.heap[1], this.heap[2]) > 0) {\r\n          let temp = this.heap[1];\r\n          this.heap[1] = this.heap[2];\r\n          this.heap[2] = temp;\r\n        }\r\n        return smallest;\r\n      }\r\n\r\n      //useful vars\r\n      let current = 1;\r\n      let leftChildIndex = current * 2;\r\n      let rightChildIndex = current * 2 + 1;\r\n      let leftChild = this.heap[leftChildIndex];\r\n      let rightChild = this.heap[rightChildIndex];\r\n      let curr = this.heap[current];\r\n\r\n      while (\r\n        leftChild != null &&\r\n        rightChild != null &&\r\n        (this.nodeComparator(curr, leftChild) >= 0 ||\r\n          this.nodeComparator(curr, rightChild) >= 0)\r\n      ) {\r\n        //left child is less than or equal to right child, swap with left\r\n        if (this.nodeComparator(leftChild, rightChild) <= 0) {\r\n          this.heap[leftChildIndex] = curr;\r\n          this.heap[current] = leftChild;\r\n          current = leftChildIndex;\r\n          //swap with right\r\n        } else {\r\n          this.heap[rightChildIndex] = curr;\r\n          this.heap[current] = rightChild;\r\n          current = rightChildIndex;\r\n        }\r\n        //update elements\r\n        leftChildIndex = current * 2;\r\n        rightChildIndex = current * 2 + 1;\r\n        leftChild = this.heap[leftChildIndex];\r\n        rightChild = this.heap[rightChildIndex];\r\n        curr = this.heap[current];\r\n      }\r\n    } else if (this.heap.length === 2) {\r\n      /* If there are only two elements in the array, we directly splice out the first element */\r\n      this.heap.splice(1, 1);\r\n    }\r\n    return smallest;\r\n  }\r\n\r\n  nodeComparator(nodeA, nodeB) {\r\n    return nodeA.f - nodeB.f;\r\n  }\r\n\r\n  includesElement(node) {\r\n    return this.heap.includes(node);\r\n  }\r\n\r\n  findElement(key) {\r\n    return this.heap.find((element) => this.equals(key, element));\r\n  }\r\n\r\n  size() {\r\n    return this.heap.size - 1;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    if (nodeA == null || nodeB == null) {\r\n      return false;\r\n    }\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\nimport Heap from \"../DataStructures/Heap\";\r\n\r\n//use the Manhattan distance heuristic\r\nexport default class ASearch extends AbstractAlgorithm {\r\n  constructor() {\r\n    const description =\r\n      \"A* Search is a greedy best-first-search algorithm that is based on Dijkstra's Algorithm. This one uses the Manhattan heuristic to determine which noes to search through. This means that the path is allowed to move up, down, left and right, but is not allowed to move diagonally\";\r\n    const name = \"A* Search Algorithm\";\r\n    const link = \"https://www.youtube.com/watch?v=ySN5Wnu88nE\";\r\n    super(name, description, link);\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    //initialize open and closed list, and make a grid where each node has a h,f,g value\r\n    const currGrid = this.getGrid(grid);\r\n    const openList = new Heap();\r\n\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    openList.push(startNode);\r\n    while (openList.heap.length > 1) {\r\n      const currentNode = openList.pop();\r\n\r\n      this.visitedNodesInOrder.push(currentNode);\r\n      currentNode.closed = true;\r\n\r\n      //we are at the finish node, the path is found\r\n      if (this.equals(currentNode, finishNode)) {\r\n        const path = [];\r\n        var current = currentNode;\r\n        while (current != null) {\r\n          path.push(current);\r\n          current = current.parent;\r\n        }\r\n        path.reverse();\r\n        this.path = path;\r\n        return true;\r\n      }\r\n\r\n      //this node is not the end, find the neighbours\r\n      const children = this.getNeighbors(currentNode, currGrid);\r\n      for (var i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        //if this node has been visited or it is a wall, then skip\r\n        if (child.closed || child.isWall) {\r\n          continue;\r\n        }\r\n\r\n        //is possible node on the path, set g, h and f values then check if its in the open list\r\n        child.parent = currentNode;\r\n        child.g = currentNode.g + 1;\r\n        child.h = this.ManhattanHeuristic(child, finishNode);\r\n        child.f = child.g + child.h;\r\n\r\n        if (openList.includesElement(child)) {\r\n          const copy = openList.findElement(child);\r\n          if (copy.g < child.g) {\r\n            continue;\r\n          }\r\n        } else {\r\n          openList.push(child);\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  contains(array, node) {\r\n    for (const element in array) {\r\n      if (node === element) {\r\n        return element;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n\r\n  //if changed heuristics is desired, then you can simply add a function, and change it in the solve function above\r\n  ManhattanHeuristic(nodeA, nodeB) {\r\n    return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n  }\r\n\r\n  //get a copy of the grid with objects that have an h,f,g property for the algorithm to solve\r\n  getGrid(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          h: 0,\r\n          f: 0,\r\n          g: 0,\r\n          isVisited: false,\r\n          closed: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n}\r\n","export default class Stack {\r\n  constructor() {\r\n    this.data = [];\r\n    this.top = 0;\r\n  }\r\n  push(element) {\r\n    this.data[this.top] = element;\r\n    this.top = this.top + 1;\r\n  }\r\n  length() {\r\n    return this.top;\r\n  }\r\n  peek() {\r\n    return this.data[this.top - 1];\r\n  }\r\n  isEmpty() {\r\n    return this.top === 0;\r\n  }\r\n  pop() {\r\n    if (this.isEmpty() === false) {\r\n      this.top = this.top - 1;\r\n      return this.data.pop(); // removes the last element\r\n    }\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\nimport Stack from \"../DataStructures/Stack\";\r\n\r\nexport default class DepthFirstSearchIterative extends AbstractAlgorithm {\r\n  constructor() {\r\n    const description =\r\n      \"Depth First Search (DFS) is an algorithm for traversing a graph that explores as far as possible along each branch before continuing. It is useful when the answer we are looking for is far away from the starting node that we are given. This particular instance of depth first search is implemented with a stack, and does not guarantee the shortest path. Note it is also possible to implement DFS with recursion.\";\r\n    const name = \"Depth First Search (Iterative)\";\r\n    const link = \"https://www.youtube.com/watch?v=7fujbpJ0LB4\";\r\n    super(name, description, link);\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    const newGrid = this.getAllNodes(grid);\r\n    const stack = new Stack();\r\n    this.visitNode(startNode, stack);\r\n    while (!stack.isEmpty()) {\r\n      const u = stack.pop();\r\n\r\n      if (this.equals(u, finishNode)) {\r\n        this.path = this.buildPath(u);\r\n        return true;\r\n      }\r\n\r\n      const neighbors = this.getNeighbors(u, newGrid);\r\n      for (let i = 0; i < neighbors.length; i++) {\r\n        const w = neighbors[i];\r\n        //check if it has been visited already or if it is a wall\r\n        if (w.isVisited || w.isWall) {\r\n          continue;\r\n        }\r\n        //not visited an not a wall, so valid node\r\n        this.visitNode(w, stack);\r\n        w.parent = u;\r\n        stack.push(w);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  visitNode(node, stack) {\r\n    stack.push(node);\r\n    this.visitedNodesInOrder.push(node);\r\n    node.isVisited = true;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          parent: null,\r\n          isVisited: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\n/*NOT WORKING - It just goes to a corner and gets stuck there */\r\nexport default class DepthFirstSearchRecursive extends AbstractAlgorithm {\r\n  constructor() {\r\n    const description =\r\n      \"Depth First Search (DFS) is an algorithm for traversing a graph that explores as far as possible along each branch before continuing. It is useful when the answer we are looking for is far away from the starting node that we are given. This particular instance of depth first search is implemented with a recursive algorithm and does not guarantee the shortest path. Note it is also possible to implement DFS iteratively using a Stack.\";\r\n    const name = \"Depth First Search (Recursive)\";\r\n    const link = \"https://www.youtube.com/watch?v=7fujbpJ0LB4\";\r\n    super(name, description, link);\r\n  }\r\n  solve(grid, startNode, finishNode) {\r\n    const currGrid = this.getAllNodes(grid);\r\n    this.traverse(currGrid, startNode, finishNode);\r\n  }\r\n\r\n  traverse(grid, startNode, finishNode) {\r\n    this.visitNode(startNode);\r\n    if (this.equals(startNode, finishNode)) {\r\n      this.path = this.buildPath(startNode);\r\n    }\r\n\r\n    const neighbors = this.getNeighbors(startNode, grid);\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      const w = neighbors[i];\r\n      //check if it has been visited already or if it is a wall\r\n      if (w.isVisited || w.isWall) {\r\n        continue;\r\n      }\r\n\r\n      w.parent = startNode;\r\n      this.traverse(grid, w, finishNode);\r\n    }\r\n  }\r\n\r\n  visitNode(node) {\r\n    this.visitedNodesInOrder.push(node);\r\n    node.isVisited = true;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          parent: null,\r\n          isVisited: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\n\r\nexport default class BreadthFirstSearch extends AbstractAlgorithm {\r\n  constructor() {\r\n    const description =\r\n      \"Breadth First Search (BFS) is an algorithm for traversing a graph that explores all neighbor nodes at the current level before continuing. This instance of Breadth First Search is implemented using a Queue. It guarantees the shortest path on unweighted graphs\";\r\n    const name = \"Breadth First Search\";\r\n    const link = \"https://www.youtube.com/watch?v=oDqjPvD54Ss\";\r\n    super(name, description, link);\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    const newGrid = this.getAllNodes(grid);\r\n    const queue = [];\r\n    this.visitNode(startNode, queue);\r\n    while (queue.length > 0) {\r\n      const u = queue.shift();\r\n\r\n      if (this.equals(u, finishNode)) {\r\n        this.path = this.buildPath(u);\r\n        return true;\r\n      }\r\n\r\n      const neighbors = this.getNeighbors(u, newGrid);\r\n      for (let i = 0; i < neighbors.length; i++) {\r\n        const w = neighbors[i];\r\n        //check if it has been visited already or if it is a wall\r\n        if (w.isVisited || w.isWall) {\r\n          continue;\r\n        }\r\n        //not visited an not a wall, so valid node\r\n        this.visitNode(w, queue);\r\n        w.parent = u;\r\n        queue.push(w);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  visitNode(node, queue) {\r\n    queue.push(node);\r\n    this.visitedNodesInOrder.push(node);\r\n    node.isVisited = true;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          parent: null,\r\n          isVisited: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n}\r\n","// function that returns a div that is an algorithm menu, allowing the user to select an algorithm\r\nimport Dijkstra from \"../../Algorithms/Dijkstra.js\";\r\nimport ASearch from \"../../Algorithms/ASearch\";\r\nimport DepthFirstSearchIterative from \"../../Algorithms/DepthFirstSearchIterative\";\r\nimport DepthFirstSearchRecursive from \"../../Algorithms/DepthFirstSearchRecursive\";\r\nimport BreadthFirstSearch from \"../../Algorithms/BreadthFirstSearch\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\n\r\nimport React from \"react\";\r\nimport List from \"@material-ui/core/List\";\r\nimport ListItem from \"@material-ui/core/ListItem\";\r\nimport ListItemText from \"@material-ui/core/ListItemText\";\r\nimport { Menu, MenuItem } from \"@material-ui/core\";\r\n\r\nimport \"./AlgorithmMenu.css\";\r\n\r\nexport default function AlgorithmMenu(props) {\r\n  /* To add more items, simply import the algorithm, and add it to the algorithms array below  */\r\n  const algorithms = [\r\n    new Dijkstra(),\r\n    new ASearch(),\r\n    new DepthFirstSearchIterative(),\r\n    new DepthFirstSearchRecursive(),\r\n    new BreadthFirstSearch(),\r\n  ];\r\n\r\n  //get the algorithm names\r\n  const options = [];\r\n  for (let i = 0; i < algorithms.length; i++) {\r\n    options.push(algorithms[i].getAlgorithmName());\r\n  }\r\n\r\n  //set the style for the menu\r\n  const useStyles = makeStyles((theme) => ({\r\n    root: {\r\n      \"& > *\": {\r\n        margin: theme.spacing(1),\r\n      },\r\n    },\r\n  }));\r\n  const [anchorEl, setAnchorEl] = React.useState(null);\r\n  const [selectedIndex, setSelectedIndex] = React.useState(0);\r\n\r\n  const handleClick = (event) => {\r\n    setAnchorEl(event.currentTarget);\r\n  };\r\n\r\n  //if the user hasn't selected an option, just close the menu\r\n  const handleClose = () => {\r\n    setAnchorEl(null);\r\n  };\r\n\r\n  //if the user has selected an option, change the algorithm and\r\n  const handleSelect = (algorithm, index) => {\r\n    const changeAlgorithm = props.handler;\r\n    setAnchorEl(null);\r\n    changeAlgorithm(algorithm);\r\n    setSelectedIndex(index);\r\n  };\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <List component=\"nav\" aria-label=\"Device settings\">\r\n        <ListItem\r\n          button\r\n          aria-haspopup=\"true\"\r\n          aria-controls=\"lock-menu\"\r\n          aria-label=\"when device is locked\"\r\n          onClick={handleClick}\r\n          variant=\"contained\"\r\n          color=\"inherited\"\r\n        >\r\n          <ListItemText\r\n            primary=\"Select an Algorithm\"\r\n            secondary={options[selectedIndex]}\r\n          />\r\n        </ListItem>\r\n      </List>\r\n      <Menu\r\n        id=\"lock-menu\"\r\n        anchorEl={anchorEl}\r\n        keepMounted\r\n        open={Boolean(anchorEl)}\r\n        onClose={handleClose}\r\n      >\r\n        {options.map((option, index) => (\r\n          <MenuItem\r\n            key={option}\r\n            selected={index === selectedIndex}\r\n            onClick={() => handleSelect(algorithms[index], index)}\r\n          >\r\n            {option}\r\n          </MenuItem>\r\n        ))}\r\n      </Menu>\r\n    </div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport List from \"@material-ui/core/List\";\r\nimport ListItem from \"@material-ui/core/ListItem\";\r\nimport ListItemText from \"@material-ui/core/ListItemText\";\r\nimport MenuItem from \"@material-ui/core/MenuItem\";\r\nimport Menu from \"@material-ui/core/Menu\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    \"&:focus\": {\r\n      backgroundColor: theme.palette.primary.main,\r\n      \"& .MuiListItemIcon-root, & .MuiListItemText-primary\": {\r\n        color: theme.palette.common.white,\r\n      },\r\n    },\r\n  },\r\n}));\r\n\r\nconst options = [\"Slow Speed\", \"Medium Speed\", \"Fast Speed\"];\r\n\r\nexport default function SpeedMenu(props) {\r\n  const classes = useStyles();\r\n  const [anchorEl, setAnchorEl] = React.useState(null);\r\n  const [selectedIndex, setSelectedIndex] = React.useState(1);\r\n\r\n  const handleClickListItem = (event) => {\r\n    setAnchorEl(event.currentTarget);\r\n  };\r\n\r\n  const handleMenuItemClick = (event, index, newSpeed) => {\r\n    const handler = props.handler;\r\n    handler(newSpeed);\r\n    setSelectedIndex(index);\r\n    setAnchorEl(null);\r\n  };\r\n\r\n  const handleClose = () => {\r\n    setAnchorEl(null);\r\n  };\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <List component=\"nav\" aria-label=\"Device settings\">\r\n        <ListItem\r\n          button\r\n          aria-haspopup=\"true\"\r\n          aria-controls=\"lock-menu\"\r\n          aria-label=\"when device is locked\"\r\n          onClick={handleClickListItem}\r\n          variant=\"contained\"\r\n          color=\"inherited\"\r\n        >\r\n          <ListItemText\r\n            primary=\"Change Speed\"\r\n            secondary={options[selectedIndex]}\r\n          />\r\n        </ListItem>\r\n      </List>\r\n      <Menu\r\n        id=\"lock-menu\"\r\n        anchorEl={anchorEl}\r\n        keepMounted\r\n        open={Boolean(anchorEl)}\r\n        onClose={handleClose}\r\n      >\r\n        {options.map((option, index) => (\r\n          <MenuItem\r\n            key={option}\r\n            selected={index === selectedIndex}\r\n            onClick={(event) => handleMenuItemClick(event, index, index)}\r\n          >\r\n            {option}\r\n          </MenuItem>\r\n        ))}\r\n      </Menu>\r\n    </div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { Button, Toolbar } from \"@material-ui/core\";\r\nimport AlgorithmMenu from \"../AlgorithmMenu/AlgorithmMenu\";\r\nimport SpeedMenu from \"../SpeedMenu/SpeedMenu\";\r\n\r\nimport \"./ButtonBox.css\";\r\n\r\nexport default function ButtonBox(props) {\r\n  return (\r\n    <div className=\"buttonBox\">\r\n      <Toolbar>\r\n        {/* Select an algorithm menu */}\r\n        <AlgorithmMenu\r\n          handler={props.algorithmChangeHandler}\r\n          variant=\"contained\"\r\n          title=\"Select an algorithm\"\r\n        ></AlgorithmMenu>\r\n\r\n        {/* Solve the problem button */}\r\n        <Button\r\n          variant=\"contained\"\r\n          color=\"primary\"\r\n          onClick={() => props.clickChild()}\r\n        >\r\n          Visualize {props.algorithm.getAlgorithmName()}\r\n        </Button>\r\n\r\n        {/* Generate a maze algorithm */}\r\n        {/* <Button\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n            onClick={() => this.clickChild()}\r\n          >\r\n            Generate a random maze\r\n          </Button> */}\r\n\r\n        {/* Select the speed menu */}\r\n        <SpeedMenu\r\n          handler={props.speedChangeHandler}\r\n          variant=\"contained\"\r\n          title=\"Change Speeds\"\r\n        ></SpeedMenu>\r\n      </Toolbar>\r\n    </div>\r\n  );\r\n}\r\n","import React from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\n//class that represents the node class, which, in aggregate forms the grid class\r\nexport default function Node(props) {\r\n  const {\r\n    col,\r\n    isFinish,\r\n    isStart,\r\n    isWall,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n    onMouseUp,\r\n    row,\r\n  } = props;\r\n  //ternary that returns if the node is a start node or finish node\r\n  const extraClassName = isFinish\r\n    ? \"node-finish\"\r\n    : isStart\r\n    ? \"node-start\"\r\n    : isWall\r\n    ? \"node-wall\"\r\n    : \"\";\r\n\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      className={`node ${extraClassName}`}\r\n      onMouseDown={() => onMouseDown(row, col)}\r\n      onMouseEnter={() => onMouseEnter(row, col)}\r\n      onMouseUp={() => onMouseUp()}\r\n    ></div>\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"../Node/Node\";\r\n//import MazeGenerator from \"../../Algorithms/MazeGenerator\";\r\n\r\n//default start and end nodes\r\nconst START_NODE_ROW = 13;\r\nconst START_NODE_COL = 5;\r\nconst FINISH_NODE_ROW = 13;\r\nconst FINISH_NODE_COL = 45;\r\n\r\n//default number of rows and cols\r\nconst NUM_ROWS = 25;\r\nconst NUM_COLS = 50;\r\n\r\nconst PATH_SPEEDS = [100, 50, 5];\r\nconst VISITED_SPEEDS = [20, 10, 1];\r\n\r\nexport default class Grid extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      rows: NUM_ROWS,\r\n      cols: NUM_COLS,\r\n      grid: [],\r\n      algorithm: null,\r\n      mouseIsPressed: false,\r\n      currentSpeed: 1,\r\n      //generator: new MazeGenerator(),\r\n    };\r\n    //bind the \"this\" keyword to the grid object in the following methods\r\n    this.visualizeAlgorithm = this.visualizeAlgorithm.bind(this);\r\n    //this.visualizeMaze = this.visualizeMaze.bind(this); //for the maze generator, not working\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  //function that animates the algorithm\r\n  //does not change the start and end node so that the user can still see where the start and end is,\r\n  //and so when the grid is refreshed the start and end nodes aren't lost\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length - 1; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, VISITED_SPEEDS[this.state.currentSpeed] * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (\r\n          document.getElementById(`node-${node.row}-${node.col}`).className ===\r\n            \"node node-start\" ||\r\n          document.getElementById(`node-${node.row}-${node.col}`).className ===\r\n            \"node node-finish\"\r\n        )\r\n          return;\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, VISITED_SPEEDS[this.state.currentSpeed] * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, PATH_SPEEDS[this.state.currentSpeed] * i);\r\n    }\r\n  }\r\n\r\n  //returns a boolean based on if a path was found or not\r\n  visualizeAlgorithm() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n    this.state.algorithm.solve(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = this.state.algorithm.getPath();\r\n    const visitedNodesInOrder = this.state.algorithm.getVisitedNodesInOrder();\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  //Code for visualizing maze - commented out because it isn't working right now\r\n  // visualizeMaze() {\r\n  //   const listOfWalls = this.state.generator.generate(\r\n  //     this.state.grid,\r\n  //     this.state.grid[0][0]\r\n  //   );\r\n  //   this.animateWalls(listOfWalls);\r\n  // }\r\n\r\n  //animates the walls by changing the classnames - this is for the maze generation algorithm\r\n  // animateWalls(listOfWalls) {\r\n  //   for (let i = 0; i < listOfWalls.length; i++) {\r\n  //     setTimeout(() => {\r\n  //       const node = listOfWalls[i];\r\n  //       if (\r\n  //         document.getElementById(`node-${node.row}-${node.col}`).className ===\r\n  //           \"node node-start\" ||\r\n  //         document.getElementById(`node-${node.row}-${node.col}`).className ===\r\n  //           \"node node-finish\"\r\n  //       ) {\r\n  //         return;\r\n  //       }\r\n  //       document.getElementById(`node-${node.row}-${node.col}`).className =\r\n  //         \"node node-wall\";\r\n  //     }, PATH_SPEEDS[this.state.currentSpeed] * i);\r\n  //   }\r\n  // }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid,\r\n      algorithm: this.props.algorithm,\r\n      currentSpeed: this.props.speed,\r\n    });\r\n    this.props.setClick(this.visualizeAlgorithm);\r\n    //this.props.setClick(this.visualizeMaze);\r\n  }\r\n\r\n  //used getDerivedStateFromProps since componentsDidUpdate() is deprecated\r\n  static getDerivedStateFromProps(props, state) {\r\n    if (props.speed !== state.currentSpeed) {\r\n      Grid.rebuildGrid(state.grid);\r\n      return { currentSpeed: props.speed };\r\n    } else if (props.algorithm !== state.algorithm) {\r\n      //ideally i would have like to compare if they are instances of the same class, but i'm not sure how to do that right now\r\n      Grid.rebuildGrid(state.grid);\r\n      return { algorithm: props.algorithm };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  render() {\r\n    const { mouseIsPressed } = this.state;\r\n    return (\r\n      <div className=\"grid\">\r\n        {this.state.grid.map((row, rowIdx) => {\r\n          return (\r\n            <div id={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const { row, col, isFinish, isStart, isWall } = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                    onMouseUp={() => this.handleMouseUp()}\r\n                    row={row}\r\n                  ></Node>\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  //re render the grid after changing algorithms\r\n  //sets the class name of all visited and path nodes to regular nodes, but leaves walls and the endpoint\r\n  //nodes as is\r\n  static rebuildGrid(grid) {\r\n    for (let row = 0; row < grid.length; row++) {\r\n      for (let col = 0; col < grid[0].length; col++) {\r\n        const className = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        if (\r\n          className === \"node node-start\" ||\r\n          className === \"node node-finish\"\r\n        ) {\r\n          continue;\r\n        } else if (\r\n          className === \"node node-shortest-path\" ||\r\n          className === \"node node-visited\"\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//function that initializes the grid\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < NUM_ROWS; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUM_COLS; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\n//function that creates a new node component\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport AppBar from \"@material-ui/core/AppBar\";\r\nimport Toolbar from \"@material-ui/core/Toolbar\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport useScrollTrigger from \"@material-ui/core/useScrollTrigger\";\r\nimport Slide from \"@material-ui/core/Slide\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    flexGrow: 1,\r\n  },\r\n  menuButton: {\r\n    marginRight: theme.spacing(0),\r\n  },\r\n  title: {\r\n    flexGrow: 1,\r\n  },\r\n}));\r\n\r\nfunction HideOnScroll(props) {\r\n  const { children, window } = props;\r\n  const trigger = useScrollTrigger({ target: window });\r\n\r\n  return (\r\n    <Slide appear={false} direction=\"down\" in={!trigger}>\r\n      {children}\r\n    </Slide>\r\n  );\r\n}\r\n\r\nexport default function TopBar(props) {\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <HideOnScroll {...props}>\r\n        <AppBar position=\"static\">\r\n          <Toolbar>\r\n            <Typography variant=\"h6\" className={classes.title}>\r\n              Pathfinding Algorithm Visualizer\r\n            </Typography>\r\n          </Toolbar>\r\n        </AppBar>\r\n      </HideOnScroll>\r\n    </div>\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nimport InformationBar from \"./InformationBar/InformationBar\";\r\nimport ButtonBox from \"./ButtonBox/ButtonBox\";\r\nimport Dijkstra from \"../Algorithms/Dijkstra.js\";\r\nimport Grid from \"./Grid/Grid\";\r\nimport TopBar from \"./TopBar/TopBar\";\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  //constructor for the app, this class is an aggregate for all the different components and serves as the communicator between all the different classes\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      algorithm: new Dijkstra(),\r\n      speed: 1,\r\n    };\r\n    //bind this in the method changeAlgorithm to the current instance of the PathfindingVisualizer\r\n    this.algorithmChangeHandler = this.changeAlgorithm.bind(this);\r\n    this.speedChangeHandler = this.changeSpeed.bind(this);\r\n  }\r\n\r\n  render() {\r\n    const algorithm = this.state.algorithm;\r\n    const speed = this.state.speed;\r\n    const generator = this.state.generator;\r\n    return (\r\n      <div className=\"App\">\r\n        {/* Make a top bar element */}\r\n        <TopBar text={\"Pathfinding Algorithm Visualizer\"}></TopBar>\r\n\r\n        {/* Make Information bar element */}\r\n        <InformationBar></InformationBar>\r\n\r\n        {/* Different buttons*/}\r\n        <ButtonBox\r\n          algorithm={this.state.algorithm}\r\n          algorithmChangeHandler={this.algorithmChangeHandler}\r\n          speedChangeHandler={this.speedChangeHandler}\r\n          clickChild={() => this.clickChild()}\r\n        ></ButtonBox>\r\n\r\n        {/* A sentence describing the algorithm */}\r\n        <div className=\"algorithmDescription\">\r\n          {`${algorithm.getAlgorithmDescription()} To learn more about ${algorithm.getAlgorithmName()}, click `}\r\n          <a\r\n            href={algorithm.getLink()}\r\n            target=\"_blank\"\r\n            rel=\"noopener noreferrer\"\r\n          >\r\n            here\r\n          </a>\r\n          .\r\n        </div>\r\n\r\n        {/* The grid */}\r\n        <Grid\r\n          algorithm={algorithm}\r\n          setClick={(click) => {\r\n            this.clickChild = click;\r\n            console.log(this.clickChild);\r\n          }}\r\n          changeAlgorithm={this.changeAlgorithm}\r\n          changeSpeed={this.changeSpeed}\r\n          speed={speed}\r\n          generator={generator}\r\n        ></Grid>\r\n\r\n        {/* Some credits */}\r\n        <div className=\"BottomBox\">\r\n          <p>\r\n            This React app was created by{\" \"}\r\n            <a\r\n              href=\"https://www.linkedin.com/in/james-b-ting/\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              James Ting\r\n            </a>{\" \"}\r\n            as a personal project to learn React and JavaScript. Check out the\r\n            source code on{\" \"}\r\n            <a\r\n              href=\"https://github.com/jamesbting/Pathfinding-Algorithm-Visualizer\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              Github\r\n            </a>\r\n            .\r\n          </p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  //function that changes the algorithm\r\n  changeAlgorithm(newAlgorithm) {\r\n    this.setState({ algorithm: newAlgorithm });\r\n  }\r\n\r\n  changeSpeed(newSpeed) {\r\n    this.setState({ speed: newSpeed });\r\n  }\r\n\r\n  solveGrid() {}\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport PathfindingVisualizer from \"./Components/PathfindingVisualizer\";\r\nimport { Helmet } from \"react-helmet\";\r\nconst TITLE = \"James Ting's Pathfinding Algorithm Visualizer\";\r\n\r\nfunction App() {\r\n  // store everything  other files, as to not break any of the autogenerated files\r\n  return (\r\n    <div className=\"App\">\r\n      <Helmet>\r\n        {\" \"}\r\n        <title>{TITLE}</title>\r\n      </Helmet>\r\n\r\n      <PathfindingVisualizer></PathfindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}