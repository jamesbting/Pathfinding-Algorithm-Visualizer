(this["webpackJsonppathfinding-algorithm-visualizer"]=this["webpackJsonppathfinding-algorithm-visualizer"]||[]).push([[0],{58:function(e,t,n){e.exports=n(74)},63:function(e,t,n){},64:function(e,t,n){},65:function(e,t,n){},66:function(e,t,n){},67:function(e,t,n){},68:function(e,t,n){},69:function(e,t,n){},73:function(e,t,n){},74:function(e,t,n){"use strict";n.r(t);var a=n(0),i=n.n(a),r=n(6),o=n.n(r),s=(n(63),n(64),n(4)),l=n(5),u=n(24),h=n(10),c=n(9),d=(n(65),n(66),function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){return Object(s.a)(this,n),t.apply(this,arguments)}return Object(l.a)(n,[{key:"render",value:function(){return i.a.createElement("div",{className:"information information--".concat(this.props.informationType)},i.a.createElement(i.a.Fragment,null,this.props.text,this.props.childComponent))}}]),n}(a.Component)),p=(n(67),function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){return Object(s.a)(this,n),t.apply(this,arguments)}return Object(l.a)(n,[{key:"render",value:function(){var e=this.props,t=e.isFinish,n=e.isStart,a=e.isWall,r=e.isPath,o=e.isVisited,s=t?"node-finish":n?"node-start":a?"node-wall":r?"node-path":o?"node-visited":"";return i.a.createElement("div",{className:"static-node ".concat(s)})}}]),n}(a.Component)),v=(n(68),function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){return Object(s.a)(this,n),t.apply(this,arguments)}return Object(l.a)(n,[{key:"render",value:function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement("div",{className:"topbar"},this.props.text,i.a.createElement("div",null,f("Start"),f("Finish"),f("Wall"),f("Path"),f("Visited"),f("Regular"))))}}]),n}(a.Component)),f=function(e){var t="Start"===e,n="Finish"===e,a="Wall"===e,r="Path"===e,o="Visited"===e;return i.a.createElement(d,{informationType:"".concat(e,"-node"),text:"".concat(e," node "),childComponent:i.a.createElement(p,{isStart:t,isFinish:n,isWall:a,isPath:r,isVisited:o})})},g=n(112),m=n(113),y=n(13),b=function(){function e(){Object(s.a)(this,e)}return Object(l.a)(e,[{key:"solve",value:function(e,t,n){}},{key:"getPath",value:function(){}},{key:"getAlgorithmDescription",value:function(){}},{key:"getAlgorithmName",value:function(){}},{key:"getVisitedNodesInOrder",value:function(){}}]),e}(),k=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).name="Dijkstra's Algorithm",e.description="Dijkstra's Algorithm is a greedy algorithm that finds the shortest path between 2 nodes. For a given source node in the graph, the algorithm finds the shortest path between the current node and every other node. While simple and viable, it is possible to improve on it's performance with algorithms such as A * Search.",e.path=[],e.visitedNodesInOrder=[],e}return Object(l.a)(n,[{key:"solve",value:function(e,t,n){var a=[];t.distance=0;for(var i=this.getAllNodes(e);i.length;){this.sortNodesByDistance(i);var r=i.shift();if(!r.isWall){if(r.distance===1/0)return this.visitedNodesInOrder=a,this.getNodesInShortestPathOrder(n),!0;if(r.isVisited=!0,a.push(r),r===n)return this.visitedNodesInOrder=a,this.getNodesInShortestPathOrder(n),!0;this.updateUnvisitedNeighbors(r,e)}}}},{key:"sortNodesByDistance",value:function(e){e.sort((function(e,t){return e.distance-t.distance}))}},{key:"updateUnvisitedNeighbors",value:function(e,t){var n,a=this.getUnvisitedNeighbors(e,t),i=Object(y.a)(a);try{for(i.s();!(n=i.n()).done;){var r=n.value;r.distance=e.distance+1,r.previousNode=e}}catch(o){i.e(o)}finally{i.f()}}},{key:"getUnvisitedNeighbors",value:function(e,t){var n=[],a=e.col,i=e.row;return i>0&&n.push(t[i-1][a]),i<t.length-1&&n.push(t[i+1][a]),a>0&&n.push(t[i][a-1]),a<t[0].length-1&&n.push(t[i][a+1]),n.filter((function(e){return!e.isVisited}))}},{key:"getAllNodes",value:function(e){var t,n=[],a=Object(y.a)(e);try{for(a.s();!(t=a.n()).done;){var i,r=t.value,o=Object(y.a)(r);try{for(o.s();!(i=o.n()).done;){var s=i.value;n.push(s)}}catch(l){o.e(l)}finally{o.f()}}}catch(l){a.e(l)}finally{a.f()}return n}},{key:"getNodesInShortestPathOrder",value:function(e){for(var t=[],n=e;null!==n;)t.unshift(n),n=n.previousNode;this.path=t}},{key:"getAlgorithmDescription",value:function(){return this.description}},{key:"getAlgorithmName",value:function(){return this.name}},{key:"getPath",value:function(){return this.path}},{key:"getVisitedNodesInOrder",value:function(){return this.visitedNodesInOrder}}]),n}(b),O=n(30),N=n(16),j=function(){function e(){Object(s.a)(this,e),this.heap=[null]}return Object(l.a)(e,[{key:"get",value:function(){return this.heap[1]}},{key:"push",value:function(e){if(this.heap.push(e),this.heap.length>1)for(var t=this.heap.length-1;t>1&&this.nodeComparator(this.heap[Math.floor(t/2)],this.heap[t])>0;){var n=this.heap[Math.floor(t/2)],a=this.heap[t];this.heap[t]=n,this.heap[Math.floor(t/2)]=a,t=Math.floor(t/2)}}},{key:"pop",value:function(){var e=this.heap[1];if(this.heap.length>2){if(this.heap[1]=this.heap[this.heap.length-1],this.heap.splice(this.heap.length-1),3===this.heap.length){if(this.nodeComparator(this.heap[1],this.heap[2])>0){var t=this.heap[1];this.heap[1]=this.heap[2],this.heap[2]=t}return e}for(var n=1,a=2*n,i=2*n+1,r=this.heap[a],o=this.heap[i],s=this.heap[n];null!=r&&null!=o&&(this.nodeComparator(s,r)>=0||this.nodeComparator(s,o)>=0);)this.nodeComparator(r,o)<=0?(this.heap[a]=s,this.heap[n]=r,n=a):(this.heap[i]=s,this.heap[n]=o,n=i),a=2*n,i=2*n+1,r=this.heap[a],o=this.heap[i],s=this.heap[n]}else 2===this.heap.length&&this.heap.splice(1,1);return e}},{key:"nodeComparator",value:function(e,t){return e.f-t.f}},{key:"includesElement",value:function(e){return this.heap.includes(e)}},{key:"findElement",value:function(e){var t=this;return this.heap.find((function(n){return t.equals(e,n)}))}},{key:"size",value:function(){return this.heap.size-1}},{key:"equals",value:function(e,t){return null!=e&&null!=t&&(e.row===t.row&&e.col===t.col)}}]),e}(),w=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).name="A* Search Algorithm",e.description="A* Search is a greedy best-first-search algorithm that is based on Dijkstra's Algorithm. This one uses the Manhattan heuristic to determine which noes to search through. This means that the path is allowed to move up, down, left and right, but is not allowed to move diagonally",e.path=[],e.visitedNodesInOrder=[],e}return Object(l.a)(n,[{key:"solve",value:function(e,t,n){var a=this.getGrid(e),i=new j;for(t.g=0,t.f=0,i.push(t);i.heap.length>1;){var r=i.pop();if(this.visitedNodesInOrder.push(r),r.closed=!0,this.equals(r,n)){for(var o=[],s=r;null!=s;)o.push(s),s=s.parent;return o.reverse(),this.path=o,!0}for(var l=this.getNeighbors(r,a),u=0;u<l.length;u++){var h=l[u];if(!h.closed&&!h.isWall)if(h.parent=r,h.g=r.g+1,h.h=this.ManhattanHeuristic(h,n),h.f=h.g+h.h,i.includesElement(h)){if(i.findElement(h).g<h.g)continue}else i.push(h)}}return!1}},{key:"contains",value:function(e,t){for(var n in e)if(t===n)return n;return null}},{key:"equals",value:function(e,t){return e.row===t.row&&e.col===t.col}},{key:"buildPath",value:function(e){for(var t=[],n=e;null!=n;)t.push(n),n=n.parent;return t.reverse(),t}},{key:"getNeighbors",value:function(e,t){var n=[],a=e.col,i=e.row;return i>0&&n.push(t[i-1][a]),i<t.length-1&&n.push(t[i+1][a]),a>0&&n.push(t[i][a-1]),a<t[0].length-1&&n.push(t[i][a+1]),n}},{key:"ManhattanHeuristic",value:function(e,t){return Math.abs(e.row-t.row)+Math.abs(e.col-t.col)}},{key:"getPath",value:function(){return this.path}},{key:"getAlgorithmDescription",value:function(){return this.description}},{key:"getAlgorithmName",value:function(){return this.name}},{key:"getNodesInShortestPathOrder",value:function(e){for(var t=[],n=e;null!==n;)t.unshift(n),n=n.previousNode;this.path=t}},{key:"getGrid",value:function(e){var t,n=[],a=Object(y.a)(e);try{for(a.s();!(t=a.n()).done;){var i,r=t.value,o=[],s=Object(y.a)(r);try{for(s.s();!(i=s.n()).done;){var l=i.value;o.push(Object(N.a)({h:0,f:0,g:0,isVisited:!1,closed:!1},l))}}catch(u){s.e(u)}finally{s.f()}n.push(o)}}catch(u){a.e(u)}finally{a.f()}return n}},{key:"getVisitedNodesInOrder",value:function(){return this.visitedNodesInOrder}}]),n}(b),E=function(){function e(){Object(s.a)(this,e),this.data=[],this.top=0}return Object(l.a)(e,[{key:"push",value:function(e){this.data[this.top]=e,this.top=this.top+1}},{key:"length",value:function(){return this.top}},{key:"peek",value:function(){return this.data[this.top-1]}},{key:"isEmpty",value:function(){return 0===this.top}},{key:"pop",value:function(){if(!1===this.isEmpty())return this.top=this.top-1,this.data.pop()}}]),e}(),S=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).name="Depth First Search (Iterative)",e.description="Depth First Search (DFS) is an algorithm for traversing a graph that explores as far as possible along each branch before continuing. It is useful when the answer we are looking for is far away from the starting node that we are given. This particular instance of depth first search is implemented with a stack, and does not guarantee the shortest path. Note it is also possible to implement DFS with recursion.",e.path=[],e.visitedNodesInOrder=[],e}return Object(l.a)(n,[{key:"solve",value:function(e,t,n){var a=this.getAllNodes(e),i=new E;for(this.visitNode(t,i);!i.isEmpty();){var r=i.pop();if(this.equals(r,n))return this.path=this.buildPath(r),!0;for(var o=this.getNeighbors(r,a),s=0;s<o.length;s++){var l=o[s];l.isVisited||l.isWall||(this.visitNode(l,i),l.parent=r,i.push(l))}}return!1}},{key:"visitNode",value:function(e,t){t.push(e),this.visitedNodesInOrder.push(e),e.isVisited=!0}},{key:"buildPath",value:function(e){for(var t=[],n=e;null!=n;)t.push(n),n=n.parent;return t.reverse(),t}},{key:"getAllNodes",value:function(e){var t,n=[],a=Object(y.a)(e);try{for(a.s();!(t=a.n()).done;){var i,r=t.value,o=[],s=Object(y.a)(r);try{for(s.s();!(i=s.n()).done;){var l=i.value;o.push(Object(N.a)({parent:null,isVisited:!1},l))}}catch(u){s.e(u)}finally{s.f()}n.push(o)}}catch(u){a.e(u)}finally{a.f()}return n}},{key:"getNeighbors",value:function(e,t){var n=[],a=e.col,i=e.row;return i>0&&n.push(t[i-1][a]),i<t.length-1&&n.push(t[i+1][a]),a>0&&n.push(t[i][a-1]),a<t[0].length-1&&n.push(t[i][a+1]),n}},{key:"equals",value:function(e,t){return e.row===t.row&&e.col===t.col}},{key:"getPath",value:function(){return this.path}},{key:"getAlgorithmDescription",value:function(){return this.description}},{key:"getAlgorithmName",value:function(){return this.name}},{key:"getVisitedNodesInOrder",value:function(){return this.visitedNodesInOrder}}]),n}(b),A=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).name="Depth First Search (Recursive)",e.description="Depth First Search (DFS) is an algorithm for traversing a graph that explores as far as possible along each branch before continuing. It is useful when the answer we are looking for is far away from the starting node that we are given. This particular instance of depth first search is implemented with a recursive algorithm and does not guarantee the shortest path. Note it is also possible to implement DFS iteratively using a Stack.",e.path=[],e.visitedNodesInOrder=[],e}return Object(l.a)(n,[{key:"solve",value:function(e,t,n){var a=this.getAllNodes(e);this.traverse(a,t,n)}},{key:"traverse",value:function(e,t,n){this.visitNode(t),this.equals(t,n)&&(this.path=this.buildPath(t));for(var a=this.getNeighbors(t,e),i=0;i<a.length;i++){var r=a[i];r.isVisited||r.isWall||(r.parent=t,this.traverse(e,r,n))}}},{key:"visitNode",value:function(e){this.visitedNodesInOrder.push(e),e.isVisited=!0}},{key:"buildPath",value:function(e){for(var t=[],n=e;null!=n;)t.push(n),n=n.parent;return t.reverse(),t}},{key:"getAllNodes",value:function(e){var t,n=[],a=Object(y.a)(e);try{for(a.s();!(t=a.n()).done;){var i,r=t.value,o=[],s=Object(y.a)(r);try{for(s.s();!(i=s.n()).done;){var l=i.value;o.push(Object(N.a)({parent:null,isVisited:!1},l))}}catch(u){s.e(u)}finally{s.f()}n.push(o)}}catch(u){a.e(u)}finally{a.f()}return n}},{key:"getNeighbors",value:function(e,t){var n=[],a=e.col,i=e.row;return i>0&&n.push(t[i-1][a]),i<t.length-1&&n.push(t[i+1][a]),a>0&&n.push(t[i][a-1]),a<t[0].length-1&&n.push(t[i][a+1]),n}},{key:"equals",value:function(e,t){return e.row===t.row&&e.col===t.col}},{key:"getPath",value:function(){return this.path}},{key:"getAlgorithmDescription",value:function(){return this.description}},{key:"getAlgorithmName",value:function(){return this.name}},{key:"getVisitedNodesInOrder",value:function(){return this.visitedNodesInOrder}}]),n}(b),I=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).name="Breadth First Search",e.description="Breadth First Search (BFS) is an algorithm for traversing a graph that explores all neighbor nodes at the current level before continuing. This instance of Breadth First Search is implemented using a Queue.",e.path=[],e.visitedNodesInOrder=[],e}return Object(l.a)(n,[{key:"solve",value:function(e,t,n){var a=this.getAllNodes(e),i=[];for(this.visitNode(t,i);i.length>0;){var r=i.shift();if(this.equals(r,n))return this.path=this.buildPath(r),!0;for(var o=this.getNeighbors(r,a),s=0;s<o.length;s++){var l=o[s];l.isVisited||l.isWall||(this.visitNode(l,i),l.parent=r,i.push(l))}}return!1}},{key:"visitNode",value:function(e,t){t.push(e),this.visitedNodesInOrder.push(e),e.isVisited=!0}},{key:"buildPath",value:function(e){for(var t=[],n=e;null!=n;)t.push(n),n=n.parent;return t.reverse(),t}},{key:"getAllNodes",value:function(e){var t,n=[],a=Object(y.a)(e);try{for(a.s();!(t=a.n()).done;){var i,r=t.value,o=[],s=Object(y.a)(r);try{for(s.s();!(i=s.n()).done;){var l=i.value;o.push(Object(N.a)({parent:null,isVisited:!1},l))}}catch(u){s.e(u)}finally{s.f()}n.push(o)}}catch(u){a.e(u)}finally{a.f()}return n}},{key:"getNeighbors",value:function(e,t){var n=[],a=e.col,i=e.row;return i>0&&n.push(t[i-1][a]),i<t.length-1&&n.push(t[i+1][a]),a>0&&n.push(t[i][a-1]),a<t[0].length-1&&n.push(t[i][a+1]),n}},{key:"equals",value:function(e,t){return e.row===t.row&&e.col===t.col}},{key:"getPath",value:function(){return this.path}},{key:"getAlgorithmDescription",value:function(){return this.description}},{key:"getAlgorithmName",value:function(){return this.name}},{key:"getVisitedNodesInOrder",value:function(){return this.visitedNodesInOrder}}]),n}(b),P=n(103),C=n(105),M=n(78),D=n(107),V=n(114),F=n(108);n(69);function B(e){for(var t=[new k,new w,new S,new A,new I],n=[],a=0;a<t.length;a++)n.push(t[a].getAlgorithmName());var r=Object(P.a)((function(e){return{root:{"& > *":{margin:e.spacing(1)}}}})),o=i.a.useState(null),s=Object(O.a)(o,2),l=s[0],u=s[1],h=i.a.useState(0),c=Object(O.a)(h,2),d=c[0],p=c[1],v=r();return i.a.createElement("div",{className:v.root},i.a.createElement(C.a,{component:"nav","aria-label":"Device settings"},i.a.createElement(M.a,{button:!0,"aria-haspopup":"true","aria-controls":"lock-menu","aria-label":"when device is locked",onClick:function(e){u(e.currentTarget)},variant:"contained",color:"inherited"},i.a.createElement(D.a,{primary:"Select an Algorithm",secondary:n[d]}))),i.a.createElement(V.a,{id:"lock-menu",anchorEl:l,keepMounted:!0,open:Boolean(l),onClose:function(){u(null)}},n.map((function(n,a){return i.a.createElement(F.a,{key:n,selected:a===d,onClick:function(){return function(t,n){var a=e.handler;u(null),a(t),p(n)}(t[a],a)}},n)}))))}n(73);var W=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){return Object(s.a)(this,n),t.apply(this,arguments)}return Object(l.a)(n,[{key:"render",value:function(){var e=this.props,t=e.col,n=e.isFinish,a=e.isStart,r=e.isWall,o=e.onMouseDown,s=e.onMouseEnter,l=e.onMouseUp,u=e.row,h=n?"node-finish":a?"node-start":r?"node-wall":"";return i.a.createElement("div",{id:"node-".concat(u,"-").concat(t),className:"node ".concat(h),onMouseDown:function(){return o(u,t)},onMouseEnter:function(){return s(u,t)},onMouseUp:function(){return l()}})}}]),n}(a.Component),T=[100,50,5],x=[20,10,1],z=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).state={rows:20,cols:50,grid:[],algorithm:null,mouseIsPressed:!1,currentSpeed:1},e.visualizeAlgorithm=e.visualizeAlgorithm.bind(Object(u.a)(e)),e}return Object(l.a)(n,[{key:"handleMouseDown",value:function(e,t){var n=G(this.state.grid,e,t);this.setState({grid:n,mouseIsPressed:!0})}},{key:"handleMouseEnter",value:function(e,t){if(this.state.mouseIsPressed){var n=G(this.state.grid,e,t);this.setState({grid:n})}}},{key:"handleMouseUp",value:function(){this.setState({mouseIsPressed:!1})}},{key:"animateAlgorithm",value:function(e,t){for(var n=this,a=function(a){if(a===e.length-1)return setTimeout((function(){n.animateShortestPath(t)}),x[n.state.currentSpeed]*a),{v:void 0};setTimeout((function(){var t=e[a];"node node-start"!==document.getElementById("node-".concat(t.row,"-").concat(t.col)).className&&(document.getElementById("node-".concat(t.row,"-").concat(t.col)).className="node node-visited")}),x[n.state.currentSpeed]*a)},i=1;i<=e.length-1;i++){var r=a(i);if("object"===typeof r)return r.v}}},{key:"animateShortestPath",value:function(e){for(var t=this,n=function(n){setTimeout((function(){var t=e[n];document.getElementById("node-".concat(t.row,"-").concat(t.col)).className="node node-shortest-path"}),T[t.state.currentSpeed]*n)},a=1;a<e.length-1;a++)n(a)}},{key:"visualizeAlgorithm",value:function(){var e=this.state.grid,t=e[10][5],n=e[10][45];this.state.algorithm.solve(e,t,n);var a=this.state.algorithm.getPath(),i=this.state.algorithm.getVisitedNodesInOrder();this.animateAlgorithm(i,a)}},{key:"componentDidMount",value:function(){var e=q();this.setState({grid:e,algorithm:this.props.algorithm,currentSpeed:this.props.speed}),this.props.setClick(this.visualizeAlgorithm)}},{key:"render",value:function(){var e=this,t=this.state.mouseIsPressed;return i.a.createElement("div",{className:"grid"},this.state.grid.map((function(n,a){return i.a.createElement("div",{key:a},n.map((function(n,a){var r=n.row,o=n.col,s=n.isFinish,l=n.isStart,u=n.isWall;return i.a.createElement(W,{key:a,col:o,isFinish:s,isStart:l,isWall:u,mouseIsPressed:t,onMouseDown:function(t,n){return e.handleMouseDown(t,n)},onMouseEnter:function(t,n){return e.handleMouseEnter(t,n)},onMouseUp:function(){return e.handleMouseUp()},row:r})})))})))}}],[{key:"getDerivedStateFromProps",value:function(e,t){return e.speed!==t.currentSpeed?{currentSpeed:e.speed}:e.algorithm!==t.algorithm?(n.rebuildGrid(t.grid),{algorithm:e.algorithm}):null}},{key:"rebuildGrid",value:function(e){for(var t=0;t<e.length;t++)for(var n=0;n<e[0].length;n++){var a=document.getElementById("node-".concat(t,"-").concat(n)).className;console.log(a),"node node-start"!==a&&"node node-end"!==a&&("node node-shortest-path"!==a&&"node node-visited"!==a||(document.getElementById("node-".concat(t,"-").concat(n)).className="node"))}}}]),n}(a.Component),q=function(){for(var e=[],t=0;t<20;t++){for(var n=[],a=0;a<50;a++)n.push(U(a,t));e.push(n)}return e},U=function(e,t){return{col:e,row:t,isStart:10===t&&5===e,isFinish:10===t&&45===e,distance:1/0,isVisited:!1,isWall:!1,previousNode:null}},G=function(e,t,n){var a=e.slice(),i=a[t][n],r=Object(N.a)(Object(N.a)({},i),{},{isWall:!i.isWall});return a[t][n]=r,a},H=n(111),R=n(40),J=n(109),L=n(110),_=Object(P.a)((function(e){return{root:{flexGrow:1},menuButton:{marginRight:e.spacing(0)},title:{flexGrow:1}}}));function Q(e){var t=e.children,n=e.window,a=Object(J.a)({target:n?n():void 0});return i.a.createElement(L.a,{appear:!1,direction:"down",in:!a},t)}function $(e){var t=_();return i.a.createElement("div",{className:t.root},i.a.createElement(Q,e,i.a.createElement(H.a,{position:"static"},i.a.createElement(g.a,null,i.a.createElement(R.a,{variant:"h6",className:t.title},"Pathfinding Algorithm Visualizer")))))}var K=Object(P.a)((function(e){return{root:{"&:focus":{backgroundColor:e.palette.primary.main,"& .MuiListItemIcon-root, & .MuiListItemText-primary":{color:e.palette.common.white}}}}})),X=["Slow Speed","Medium Speed","Fast Speed"];function Y(e){var t=K(),n=i.a.useState(null),a=Object(O.a)(n,2),r=a[0],o=a[1],s=i.a.useState(1),l=Object(O.a)(s,2),u=l[0],h=l[1];return i.a.createElement("div",{className:t.root},i.a.createElement(C.a,{component:"nav","aria-label":"Device settings"},i.a.createElement(M.a,{button:!0,"aria-haspopup":"true","aria-controls":"lock-menu","aria-label":"when device is locked",onClick:function(e){o(e.currentTarget)},variant:"contained",color:"inherited"},i.a.createElement(D.a,{primary:"Change Speed",secondary:X[u]}))),i.a.createElement(V.a,{id:"lock-menu",anchorEl:r,keepMounted:!0,open:Boolean(r),onClose:function(){o(null)}},X.map((function(t,n){return i.a.createElement(F.a,{key:t,selected:n===u,onClick:function(t){return function(t,n,a){(0,e.handler)(a),h(n),o(null)}(0,n,n)}},t)}))))}var Z=function(e){Object(h.a)(n,e);var t=Object(c.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).state={algorithm:new k,speed:1},e.algorithmChangeHandler=e.changeAlgorithm.bind(Object(u.a)(e)),e.speedChangeHandler=e.changeSpeed.bind(Object(u.a)(e)),e}return Object(l.a)(n,[{key:"render",value:function(){var e=this,t=this.state.algorithm,n=this.state.speed;return i.a.createElement("div",{className:"app"},i.a.createElement($,{text:"Pathfinding Algorithm Visualizer"}),i.a.createElement(v,null),i.a.createElement(g.a,null,i.a.createElement(B,{handler:this.algorithmChangeHandler,variant:"contained",title:"Select an algorithm"}),i.a.createElement(m.a,{variant:"contained",color:"primary",onClick:function(){return e.clickChild()}},"Visualize ",t.getAlgorithmName()),i.a.createElement(Y,{handler:this.speedChangeHandler,variant:"contained",title:"Change Speeds"})),i.a.createElement("div",{className:"algorithm-description"},t.getAlgorithmDescription()),i.a.createElement(z,{algorithm:t,setClick:function(t){return e.clickChild=t},changeAlgorithm:this.changeAlgorithm,changeSpeed:this.changeSpeed,speed:n}),i.a.createElement("div",{className:"BottomBox"},i.a.createElement("p",null,"This React app was created by"," ",i.a.createElement("a",{href:"https://www.linkedin.com/in/james-b-ting/",target:"_blank",rel:"noopener noreferrer"},"James Ting")," ","as a personal project to learn React and JavaScript. Check out the source code on"," ",i.a.createElement("a",{href:"https://github.com/jamesbting/Pathfinding-Algorithm-Visualizer",target:"_blank",rel:"noopener noreferrer"},"Github"),".")))}},{key:"changeAlgorithm",value:function(e){this.setState({algorithm:e})}},{key:"changeSpeed",value:function(e){this.setState({speed:e})}}]),n}(a.Component);var ee=function(){return i.a.createElement("div",{className:"App"},i.a.createElement(Z,null))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));o.a.render(i.a.createElement(i.a.StrictMode,null,i.a.createElement(ee,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))}},[[58,1,2]]]);
//# sourceMappingURL=main.1de5a8c6.chunk.js.map