{"version":3,"sources":["Components/InformationBox/InformationBox.jsx","Components/StaticNode/StaticNode.jsx","Components/InformationBar/InformationBar.jsx","Algorithms/AbstractAlgorithm.js","Algorithms/Dijkstra.js","DataStructures/Heap.js","Algorithms/ASearch.js","DataStructures/Stack.js","Algorithms/DepthFirstSearchIterative.js","Algorithms/DepthFirstSearchRecursive.js","Algorithms/BreadthFirstSearch.js","Components/AlgorithmMenu/AlgorithmMenu.jsx","Components/Node/Node.jsx","Components/Grid/Grid.jsx","Components/TopBar/TopBar.jsx","Components/SpeedMenu/SpeedMenu.jsx","Components/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["InformationBox","className","this","props","informationType","text","childComponent","Component","StaticNode","isFinish","isStart","isWall","isPath","isVisited","extraClassName","InformationBar","createInformationBox","type","AbstractAlgorithm","grid","startNode","finishNode","Dijkstra","name","description","path","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","getNodesInShortestPathOrder","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes","nodesInShortestPathOrder","currentNode","unshift","Heap","heap","current","nodeComparator","Math","floor","next","curr","smallest","splice","temp","leftChildIndex","rightChildIndex","leftChild","rightChild","f","includes","key","find","element","equals","size","ASearch","currGrid","getGrid","openList","g","pop","closed","parent","reverse","children","getNeighbors","i","child","h","ManhattanHeuristic","includesElement","findElement","array","lastNode","abs","newGrid","newRow","Stack","data","top","isEmpty","DepthFirstSearchIterative","stack","visitNode","u","buildPath","w","DepthFirstSearchRecursive","traverse","BreadthFirstSearch","queue","AlgorithmMenu","algorithms","options","getAlgorithmName","useStyles","makeStyles","theme","root","margin","spacing","React","useState","anchorEl","setAnchorEl","selectedIndex","setSelectedIndex","classes","List","component","aria-label","ListItem","button","aria-haspopup","aria-controls","onClick","event","currentTarget","variant","color","ListItemText","primary","secondary","Menu","id","keepMounted","open","Boolean","onClose","map","option","index","MenuItem","selected","algorithm","changeAlgorithm","handler","handleSelect","Node","onMouseDown","onMouseEnter","onMouseUp","PATH_SPEEDS","VISITED_SPEEDS","Grid","state","rows","cols","mouseIsPressed","currentSpeed","visualizeAlgorithm","bind","getNewGridWithWallToggled","setState","setTimeout","animateShortestPath","document","getElementById","solve","getPath","getVisitedNodesInOrder","animateAlgorithm","getInitialGrid","speed","setClick","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","rebuildGrid","console","log","currentRow","createNode","slice","newNode","flexGrow","menuButton","marginRight","title","HideOnScroll","window","trigger","useScrollTrigger","target","undefined","Slide","appear","direction","in","ButtonAppBar","AppBar","position","Toolbar","Typography","backgroundColor","palette","main","common","white","SimpleListMenu","newSpeed","handleMenuItemClick","PathfindingVisualizer","algorithmChangeHandler","speedChangeHandler","changeSpeed","Button","clickChild","getAlgorithmDescription","click","href","rel","newAlgorithm","App","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.be6d1956.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./InformationBox.css\";\r\n// class that represents the box that wraps the pictorial representations of the different types of nodes\r\nexport default class InformationBox extends Component {\r\n  render() {\r\n    return (\r\n      <div className={`information information--${this.props.informationType}`}>\r\n        <>\r\n          {this.props.text}\r\n          {this.props.childComponent}\r\n        </>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport \"./StaticNode.css\";\r\n/// class that represents a static node, that is used with the information box, to depict the different types of nodes\r\nexport default class StaticNode extends Component {\r\n  render() {\r\n    const { isFinish, isStart, isWall, isPath, isVisited } = this.props;\r\n    //ternary that create an extra classname for CSS coloring.\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isPath\r\n      ? \"node-path\"\r\n      : isVisited\r\n      ? \"node-visited\"\r\n      : \"\";\r\n\r\n    return <div className={`static-node ${extraClassName}`}></div>;\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport InformationBox from \"../InformationBox/InformationBox\";\r\nimport StaticNode from \"../StaticNode/StaticNode\";\r\n\r\nimport \"./InformationBar.css\";\r\n\r\n//class that represents the top portion above the grid, and is an container for the static node classes\r\nexport default class InformationBar extends Component {\r\n  render() {\r\n    return (\r\n      <>\r\n        <div className=\"topbar\">\r\n          {this.props.text}\r\n          <div>\r\n            {createInformationBox(\"Start\")}\r\n            {createInformationBox(\"Finish\")}\r\n            {createInformationBox(\"Wall\")}\r\n            {createInformationBox(\"Path\")}\r\n            {createInformationBox(\"Visited\")}\r\n            {createInformationBox(\"Regular\")}\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\nconst createInformationBox = (type) => {\r\n  const isStart = type === \"Start\";\r\n  const isFinish = type === \"Finish\";\r\n  const isWall = type === \"Wall\";\r\n  const isPath = type === \"Path\";\r\n  const isVisited = type === \"Visited\";\r\n  return (\r\n    <InformationBox\r\n      informationType={`${type}-node`}\r\n      text={`${type} node `}\r\n      childComponent={\r\n        <StaticNode\r\n          isStart={isStart}\r\n          isFinish={isFinish}\r\n          isWall={isWall}\r\n          isPath={isPath}\r\n          isVisited={isVisited}\r\n        ></StaticNode>\r\n      }\r\n    ></InformationBox>\r\n  );\r\n};\r\n","//Abstract class that should be an extended for the making the algorithm\r\n//Should not be instantiated\r\n//each concrete extension of this class should have 4 attributes\r\n//1) name : the name of the algorithm\r\n//2) description: a short sentence or 2 that describes the algorithm\r\n//3) path: an array of nodes that represents the last solved path\r\n//4) visitedNodesInOrder: an array of nodes that represents the last set of nodes that were visited, in the order that they were visited\r\n\r\nexport class AbstractAlgorithm {\r\n  // function that takes as input a grid, as well as the start and end node, which\r\n  solve(grid, startNode, finishNode) {}\r\n\r\n  //some getter methods\r\n  getPath() {}\r\n\r\n  getAlgorithmDescription() {}\r\n\r\n  getAlgorithmName() {}\r\n\r\n  getVisitedNodesInOrder() {}\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nimport { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\n\r\n//can improve the speed by using a min heap\r\nexport default class Dijkstra extends AbstractAlgorithm {\r\n  constructor() {\r\n    super();\r\n    this.name = \"Dijkstra's Algorithm\";\r\n    this.description =\r\n      \"Dijkstra's Algorithm is a greedy algorithm that finds the shortest path between 2 nodes. For a given source node in the graph, the algorithm finds the shortest path between the current node and every other node. While simple and viable, it is possible to improve on it's performance with algorithms such as A * Search.\";\r\n    this.path = [];\r\n    this.visitedNodesInOrder = [];\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = this.getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n      //while there are unvisitedNodes in the queue,\r\n\r\n      this.sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall) continue;\r\n\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) {\r\n        this.visitedNodesInOrder = visitedNodesInOrder;\r\n        this.getNodesInShortestPathOrder(finishNode);\r\n        return true;\r\n      }\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) {\r\n        this.visitedNodesInOrder = visitedNodesInOrder;\r\n        this.getNodesInShortestPathOrder(finishNode);\r\n        return true;\r\n      }\r\n      this.updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n\r\n  //takes a list of nodes and sorts them by their distance from the start node in ascending order\r\n  sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n\r\n  updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = this.getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n\r\n  getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n\r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the solve method above.\r\n  //updates the path attribute\r\n  getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    this.path = nodesInShortestPathOrder;\r\n  }\r\n\r\n  getAlgorithmDescription() {\r\n    return this.description;\r\n  }\r\n  getAlgorithmName() {\r\n    return this.name;\r\n  }\r\n  getPath() {\r\n    return this.path;\r\n  }\r\n  getVisitedNodesInOrder() {\r\n    return this.visitedNodesInOrder;\r\n  }\r\n}\r\n","//this class represents a min heap\r\n//TODO: Fix the heap so that it works\r\nexport default class Heap {\r\n  constructor() {\r\n    this.heap = [null]; // dummy element at index 0\r\n  }\r\n\r\n  get() {\r\n    return this.heap[1];\r\n  }\r\n\r\n  push(node) {\r\n    //push it to the end of the node\r\n    this.heap.push(node);\r\n    if (this.heap.length > 1) {\r\n      let current = this.heap.length - 1;\r\n\r\n      //upheap the node to its correct position\r\n      while (\r\n        current > 1 &&\r\n        this.nodeComparator(\r\n          this.heap[Math.floor(current / 2)],\r\n          this.heap[current]\r\n        ) > 0\r\n      ) {\r\n        let next = this.heap[Math.floor(current / 2)];\r\n        let curr = this.heap[current];\r\n        this.heap[current] = next;\r\n        this.heap[Math.floor(current / 2)] = curr;\r\n        current = Math.floor(current / 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  pop() {\r\n    let smallest = this.heap[1];\r\n\r\n    if (this.heap.length > 2) {\r\n      this.heap[1] = this.heap[this.heap.length - 1];\r\n      this.heap.splice(this.heap.length - 1);\r\n\r\n      //down heap the element to its correct position\r\n      if (this.heap.length === 3) {\r\n        if (this.nodeComparator(this.heap[1], this.heap[2]) > 0) {\r\n          let temp = this.heap[1];\r\n          this.heap[1] = this.heap[2];\r\n          this.heap[2] = temp;\r\n        }\r\n        return smallest;\r\n      }\r\n\r\n      //useful vars\r\n      let current = 1;\r\n      let leftChildIndex = current * 2;\r\n      let rightChildIndex = current * 2 + 1;\r\n      let leftChild = this.heap[leftChildIndex];\r\n      let rightChild = this.heap[rightChildIndex];\r\n      let curr = this.heap[current];\r\n\r\n      while (\r\n        leftChild != null &&\r\n        rightChild != null &&\r\n        (this.nodeComparator(curr, leftChild) >= 0 ||\r\n          this.nodeComparator(curr, rightChild) >= 0)\r\n      ) {\r\n        //left child is less than or equal to right child, swap with left\r\n        if (this.nodeComparator(leftChild, rightChild) <= 0) {\r\n          this.heap[leftChildIndex] = curr;\r\n          this.heap[current] = leftChild;\r\n          current = leftChildIndex;\r\n          //swap with right\r\n        } else {\r\n          this.heap[rightChildIndex] = curr;\r\n          this.heap[current] = rightChild;\r\n          current = rightChildIndex;\r\n        }\r\n        //update elements\r\n        leftChildIndex = current * 2;\r\n        rightChildIndex = current * 2 + 1;\r\n        leftChild = this.heap[leftChildIndex];\r\n        rightChild = this.heap[rightChildIndex];\r\n        curr = this.heap[current];\r\n      }\r\n    } else if (this.heap.length === 2) {\r\n      /* If there are only two elements in the array, we directly splice out the first element */\r\n      this.heap.splice(1, 1);\r\n    }\r\n    return smallest;\r\n  }\r\n\r\n  nodeComparator(nodeA, nodeB) {\r\n    return nodeA.f - nodeB.f;\r\n  }\r\n\r\n  includesElement(node) {\r\n    return this.heap.includes(node);\r\n  }\r\n\r\n  findElement(key) {\r\n    return this.heap.find((element) => this.equals(key, element));\r\n  }\r\n\r\n  size() {\r\n    return this.heap.size - 1;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    if (nodeA == null || nodeB == null) {\r\n      return false;\r\n    }\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\nimport Heap from \"../DataStructures/Heap\";\r\n\r\n//use the Manhattan distance heuristic\r\nexport default class ASearch extends AbstractAlgorithm {\r\n  constructor() {\r\n    super();\r\n    this.name = \"A* Search Algorithm\";\r\n    this.description =\r\n      \"A* Search is a greedy best-first-search algorithm that is based on Dijkstra's Algorithm. This one uses the Manhattan heuristic to determine which noes to search through. This means that the path is allowed to move up, down, left and right, but is not allowed to move diagonally\";\r\n    this.path = [];\r\n    this.visitedNodesInOrder = [];\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    //initialize open and closed list, and make a grid where each node has a h,f,g value\r\n    const currGrid = this.getGrid(grid);\r\n    const openList = new Heap();\r\n\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    openList.push(startNode);\r\n    while (openList.heap.length > 1) {\r\n      const currentNode = openList.pop();\r\n\r\n      this.visitedNodesInOrder.push(currentNode);\r\n      currentNode.closed = true;\r\n\r\n      //we are at the finish node, the path is found\r\n      if (this.equals(currentNode, finishNode)) {\r\n        const path = [];\r\n        var current = currentNode;\r\n        while (current != null) {\r\n          path.push(current);\r\n          current = current.parent;\r\n        }\r\n        path.reverse();\r\n        this.path = path;\r\n        return true;\r\n      }\r\n\r\n      //this node is not the end, find the neighbours\r\n      const children = this.getNeighbors(currentNode, currGrid);\r\n      for (var i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        //if this node has been visited or it is a wall, then skip\r\n        if (child.closed || child.isWall) {\r\n          continue;\r\n        }\r\n\r\n        //is possible node on the path, set g, h and f values then check if its in the open list\r\n        child.parent = currentNode;\r\n        child.g = currentNode.g + 1;\r\n        child.h = this.ManhattanHeuristic(child, finishNode);\r\n        child.f = child.g + child.h;\r\n\r\n        if (openList.includesElement(child)) {\r\n          const copy = openList.findElement(child);\r\n          if (copy.g < child.g) {\r\n            continue;\r\n          }\r\n        } else {\r\n          openList.push(child);\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  contains(array, node) {\r\n    for (const element in array) {\r\n      if (node === element) {\r\n        return element;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n\r\n  //if changed heuristics is desired, then you can simply add a function, and change it in the solve function above\r\n  ManhattanHeuristic(nodeA, nodeB) {\r\n    return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n  }\r\n  getPath() {\r\n    return this.path;\r\n  }\r\n\r\n  getAlgorithmDescription() {\r\n    return this.description;\r\n  }\r\n\r\n  getAlgorithmName() {\r\n    return this.name;\r\n  }\r\n\r\n  getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    this.path = nodesInShortestPathOrder;\r\n  }\r\n\r\n  getGrid(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          h: 0,\r\n          f: 0,\r\n          g: 0,\r\n          isVisited: false,\r\n          closed: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n\r\n  getVisitedNodesInOrder() {\r\n    return this.visitedNodesInOrder;\r\n  }\r\n}\r\n","export default class Stack {\r\n  constructor() {\r\n    this.data = [];\r\n    this.top = 0;\r\n  }\r\n  push(element) {\r\n    this.data[this.top] = element;\r\n    this.top = this.top + 1;\r\n  }\r\n  length() {\r\n    return this.top;\r\n  }\r\n  peek() {\r\n    return this.data[this.top - 1];\r\n  }\r\n  isEmpty() {\r\n    return this.top === 0;\r\n  }\r\n  pop() {\r\n    if (this.isEmpty() === false) {\r\n      this.top = this.top - 1;\r\n      return this.data.pop(); // removes the last element\r\n    }\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\nimport Stack from \"../DataStructures/Stack\";\r\n\r\nexport default class DepthFirstSearchIterative extends AbstractAlgorithm {\r\n  constructor() {\r\n    super();\r\n    this.name = \"Depth First Search (Iterative)\";\r\n    this.description =\r\n      \"Depth First Search (DFS) is an algorithm for traversing a graph that explores as far as possible along each branch before continuing. It is useful when the answer we are looking for is far away from the starting node that we are given. This particular instance of depth first search is implemented with a stack, and does not guarantee the shortest path. Note it is also possible to implement DFS with recursion.\";\r\n    this.path = [];\r\n    this.visitedNodesInOrder = [];\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    const newGrid = this.getAllNodes(grid);\r\n    const stack = new Stack();\r\n    this.visitNode(startNode, stack);\r\n    while (!stack.isEmpty()) {\r\n      const u = stack.pop();\r\n\r\n      if (this.equals(u, finishNode)) {\r\n        this.path = this.buildPath(u);\r\n        return true;\r\n      }\r\n\r\n      const neighbors = this.getNeighbors(u, newGrid);\r\n      for (let i = 0; i < neighbors.length; i++) {\r\n        const w = neighbors[i];\r\n        //check if it has been visited already or if it is a wall\r\n        if (w.isVisited || w.isWall) {\r\n          continue;\r\n        }\r\n        //not visited an not a wall, so valid node\r\n        this.visitNode(w, stack);\r\n        w.parent = u;\r\n        stack.push(w);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  visitNode(node, stack) {\r\n    stack.push(node);\r\n    this.visitedNodesInOrder.push(node);\r\n    node.isVisited = true;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          parent: null,\r\n          isVisited: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n  //some getter methods to return properties of the object\r\n  getPath() {\r\n    return this.path;\r\n  }\r\n\r\n  getAlgorithmDescription() {\r\n    return this.description;\r\n  }\r\n\r\n  getAlgorithmName() {\r\n    return this.name;\r\n  }\r\n\r\n  getVisitedNodesInOrder() {\r\n    return this.visitedNodesInOrder;\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\n/*NOT WORKING - It just goes to a corner and gets stuck there */\r\nexport default class DepthFirstSearchRecursive extends AbstractAlgorithm {\r\n  constructor() {\r\n    super();\r\n    this.name = \"Depth First Search (Recursive)\";\r\n    this.description =\r\n      \"Depth First Search (DFS) is an algorithm for traversing a graph that explores as far as possible along each branch before continuing. It is useful when the answer we are looking for is far away from the starting node that we are given. This particular instance of depth first search is implemented with a recursive algorithm and does not guarantee the shortest path. Note it is also possible to implement DFS iteratively using a Stack.\";\r\n    this.path = [];\r\n    this.visitedNodesInOrder = [];\r\n  }\r\n  solve(grid, startNode, finishNode) {\r\n    const currGrid = this.getAllNodes(grid);\r\n    this.traverse(currGrid, startNode, finishNode);\r\n  }\r\n\r\n  traverse(grid, startNode, finishNode) {\r\n    this.visitNode(startNode);\r\n    if (this.equals(startNode, finishNode)) {\r\n      this.path = this.buildPath(startNode);\r\n    }\r\n\r\n    const neighbors = this.getNeighbors(startNode, grid);\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      const w = neighbors[i];\r\n      //check if it has been visited already or if it is a wall\r\n      if (w.isVisited || w.isWall) {\r\n        continue;\r\n      }\r\n\r\n      w.parent = startNode;\r\n      this.traverse(grid, w, finishNode);\r\n    }\r\n  }\r\n\r\n  visitNode(node) {\r\n    this.visitedNodesInOrder.push(node);\r\n    node.isVisited = true;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          parent: null,\r\n          isVisited: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n  //some getter methods to return properties of the object\r\n  getPath() {\r\n    return this.path;\r\n  }\r\n\r\n  getAlgorithmDescription() {\r\n    return this.description;\r\n  }\r\n\r\n  getAlgorithmName() {\r\n    return this.name;\r\n  }\r\n\r\n  getVisitedNodesInOrder() {\r\n    return this.visitedNodesInOrder;\r\n  }\r\n}\r\n","import { AbstractAlgorithm } from \"./AbstractAlgorithm\";\r\n\r\nexport default class BreadthFirstSearch extends AbstractAlgorithm {\r\n  constructor() {\r\n    super();\r\n    this.name = \"Breadth First Search\";\r\n    this.description =\r\n      \"Breadth First Search (BFS) is an algorithm for traversing a graph that explores all neighbor nodes at the current level before continuing. This instance of Breadth First Search is implemented using a Queue.\";\r\n    this.path = [];\r\n    this.visitedNodesInOrder = [];\r\n  }\r\n\r\n  solve(grid, startNode, finishNode) {\r\n    const newGrid = this.getAllNodes(grid);\r\n    const queue = [];\r\n    this.visitNode(startNode, queue);\r\n    while (queue.length > 0) {\r\n      const u = queue.shift();\r\n\r\n      if (this.equals(u, finishNode)) {\r\n        this.path = this.buildPath(u);\r\n        return true;\r\n      }\r\n\r\n      const neighbors = this.getNeighbors(u, newGrid);\r\n      for (let i = 0; i < neighbors.length; i++) {\r\n        const w = neighbors[i];\r\n        //check if it has been visited already or if it is a wall\r\n        if (w.isVisited || w.isWall) {\r\n          continue;\r\n        }\r\n        //not visited an not a wall, so valid node\r\n        this.visitNode(w, queue);\r\n        w.parent = u;\r\n        queue.push(w);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  visitNode(node, queue) {\r\n    queue.push(node);\r\n    this.visitedNodesInOrder.push(node);\r\n    node.isVisited = true;\r\n  }\r\n\r\n  buildPath(lastNode) {\r\n    const path = [];\r\n    var current = lastNode;\r\n    while (current != null) {\r\n      path.push(current);\r\n      current = current.parent;\r\n    }\r\n    path.reverse();\r\n    return path;\r\n  }\r\n\r\n  getAllNodes(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n      const newRow = [];\r\n      for (const node of row) {\r\n        newRow.push({\r\n          parent: null,\r\n          isVisited: false,\r\n          ...node,\r\n        });\r\n      }\r\n      newGrid.push(newRow);\r\n    }\r\n    return newGrid;\r\n  }\r\n\r\n  getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors;\r\n  }\r\n  equals(nodeA, nodeB) {\r\n    return nodeA.row === nodeB.row && nodeA.col === nodeB.col;\r\n  }\r\n  //some getter methods to return properties of the object\r\n  getPath() {\r\n    return this.path;\r\n  }\r\n\r\n  getAlgorithmDescription() {\r\n    return this.description;\r\n  }\r\n\r\n  getAlgorithmName() {\r\n    return this.name;\r\n  }\r\n\r\n  getVisitedNodesInOrder() {\r\n    return this.visitedNodesInOrder;\r\n  }\r\n}\r\n","// function that returns a div that is an algorithm menu, allowing the user to select an algorithm\r\nimport Dijkstra from \"../../Algorithms/Dijkstra.js\";\r\nimport ASearch from \"../../Algorithms/ASearch\";\r\nimport DepthFirstSearchIterative from \"../../Algorithms/DepthFirstSearchIterative\";\r\nimport DepthFirstSearchRecursive from \"../../Algorithms/DepthFirstSearchRecursive\";\r\nimport BreadthFirstSearch from \"../../Algorithms/BreadthFirstSearch\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\n\r\nimport React from \"react\";\r\nimport List from \"@material-ui/core/List\";\r\nimport ListItem from \"@material-ui/core/ListItem\";\r\nimport ListItemText from \"@material-ui/core/ListItemText\";\r\nimport { Menu, MenuItem } from \"@material-ui/core\";\r\n\r\nimport \"./AlgorithmMenu.css\";\r\n\r\nexport default function AlgorithmMenu(props) {\r\n  /* To add more items, simply import the algorithm, and add it to the algorithms array below  */\r\n  const algorithms = [\r\n    new Dijkstra(),\r\n    new ASearch(),\r\n    new DepthFirstSearchIterative(),\r\n    new DepthFirstSearchRecursive(),\r\n    new BreadthFirstSearch(),\r\n  ];\r\n\r\n  //get the algorithm names\r\n  const options = [];\r\n  for (let i = 0; i < algorithms.length; i++) {\r\n    options.push(algorithms[i].getAlgorithmName());\r\n  }\r\n\r\n  //set the style for the menu\r\n  const useStyles = makeStyles((theme) => ({\r\n    root: {\r\n      \"& > *\": {\r\n        margin: theme.spacing(1),\r\n      },\r\n    },\r\n  }));\r\n  const [anchorEl, setAnchorEl] = React.useState(null);\r\n  const [selectedIndex, setSelectedIndex] = React.useState(0);\r\n\r\n  const handleClick = (event) => {\r\n    setAnchorEl(event.currentTarget);\r\n  };\r\n\r\n  //if the user hasn't selected an option, just close the menu\r\n  const handleClose = () => {\r\n    setAnchorEl(null);\r\n  };\r\n\r\n  //if the user has selected an option, change the algorithm and\r\n  const handleSelect = (algorithm, index) => {\r\n    const changeAlgorithm = props.handler;\r\n    setAnchorEl(null);\r\n    changeAlgorithm(algorithm);\r\n    setSelectedIndex(index);\r\n  };\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <List component=\"nav\" aria-label=\"Device settings\">\r\n        <ListItem\r\n          button\r\n          aria-haspopup=\"true\"\r\n          aria-controls=\"lock-menu\"\r\n          aria-label=\"when device is locked\"\r\n          onClick={handleClick}\r\n          variant=\"contained\"\r\n          color=\"inherited\"\r\n        >\r\n          <ListItemText\r\n            primary=\"Select an Algorithm\"\r\n            secondary={options[selectedIndex]}\r\n          />\r\n        </ListItem>\r\n      </List>\r\n      <Menu\r\n        id=\"lock-menu\"\r\n        anchorEl={anchorEl}\r\n        keepMounted\r\n        open={Boolean(anchorEl)}\r\n        onClose={handleClose}\r\n      >\r\n        {options.map((option, index) => (\r\n          <MenuItem\r\n            key={option}\r\n            selected={index === selectedIndex}\r\n            onClick={() => handleSelect(algorithms[index], index)}\r\n          >\r\n            {option}\r\n          </MenuItem>\r\n        ))}\r\n      </Menu>\r\n    </div>\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\n//class that represents the node class, which, in aggregate forms the grid class\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    //ternary that returns if the node is a start node or finish node\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"../Node/Node\";\r\n//default start and end nodes\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 5;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 45;\r\n//default number of rows and cols\r\nconst NUM_ROWS = 20;\r\nconst NUM_COLS = 50;\r\n\r\nconst PATH_SPEEDS = [100, 50, 5];\r\nconst VISITED_SPEEDS = [20, 10, 1];\r\n\r\nexport default class Grid extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      rows: NUM_ROWS,\r\n      cols: NUM_COLS,\r\n      grid: [],\r\n      algorithm: null,\r\n      mouseIsPressed: false,\r\n      currentSpeed: 1,\r\n    };\r\n    //bind the \"this\" keyword to the grid object in the following methods\r\n    this.visualizeAlgorithm = this.visualizeAlgorithm.bind(this);\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  //function that animates the algorithm\r\n  //does not change the start and end node so that the user can still see where the start and end is,\r\n  //and so when the grid is refreshed the start and end nodes aren't lost\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length - 1; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, VISITED_SPEEDS[this.state.currentSpeed] * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (\r\n          document.getElementById(`node-${node.row}-${node.col}`).className ===\r\n          \"node node-start\"\r\n        )\r\n          return;\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, VISITED_SPEEDS[this.state.currentSpeed] * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, PATH_SPEEDS[this.state.currentSpeed] * i);\r\n    }\r\n  }\r\n\r\n  //returns a boolean based on if a path was found or not\r\n  visualizeAlgorithm() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n    this.state.algorithm.solve(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = this.state.algorithm.getPath();\r\n    const visitedNodesInOrder = this.state.algorithm.getVisitedNodesInOrder();\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid,\r\n      algorithm: this.props.algorithm,\r\n      currentSpeed: this.props.speed,\r\n    });\r\n    this.props.setClick(this.visualizeAlgorithm);\r\n  }\r\n\r\n  static getDerivedStateFromProps(props, state) {\r\n    if (props.speed !== state.currentSpeed) {\r\n      return { currentSpeed: props.speed };\r\n    } else if (props.algorithm !== state.algorithm) {\r\n      //ideally i would have like to compare if they are instances of the same class, but i'm not sure how to do that right now\r\n      Grid.rebuildGrid(state.grid);\r\n      return { algorithm: props.algorithm };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  render() {\r\n    const { mouseIsPressed } = this.state;\r\n    return (\r\n      <div className=\"grid\">\r\n        {this.state.grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const { row, col, isFinish, isStart, isWall } = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                    onMouseUp={() => this.handleMouseUp()}\r\n                    row={row}\r\n                  ></Node>\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  //re render the grid after changing algorithms - not working at the moment\r\n  static rebuildGrid(grid) {\r\n    for (let row = 0; row < grid.length; row++) {\r\n      for (let col = 0; col < grid[0].length; col++) {\r\n        const className = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        console.log(className);\r\n        if (className === \"node node-start\" || className === \"node node-end\") {\r\n          continue;\r\n        } else if (\r\n          className === \"node node-shortest-path\" ||\r\n          className === \"node node-visited\"\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//function that initializes the grid\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < NUM_ROWS; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUM_COLS; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\n//function that creates a new node component\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport AppBar from \"@material-ui/core/AppBar\";\r\nimport Toolbar from \"@material-ui/core/Toolbar\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport useScrollTrigger from \"@material-ui/core/useScrollTrigger\";\r\nimport Slide from \"@material-ui/core/Slide\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    flexGrow: 1,\r\n  },\r\n  menuButton: {\r\n    marginRight: theme.spacing(0),\r\n  },\r\n  title: {\r\n    flexGrow: 1,\r\n  },\r\n}));\r\n\r\nfunction HideOnScroll(props) {\r\n  const { children, window } = props;\r\n  // Note that you normally won't need to set the window ref as useScrollTrigger\r\n  // will default to window.\r\n  // This is only being set here because the demo is in an iframe.\r\n  const trigger = useScrollTrigger({ target: window ? window() : undefined });\r\n\r\n  return (\r\n    <Slide appear={false} direction=\"down\" in={!trigger}>\r\n      {children}\r\n    </Slide>\r\n  );\r\n}\r\n\r\nexport default function ButtonAppBar(props) {\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <HideOnScroll {...props}>\r\n        <AppBar position=\"static\">\r\n          <Toolbar>\r\n            <Typography variant=\"h6\" className={classes.title}>\r\n              Pathfinding Algorithm Visualizer\r\n            </Typography>\r\n            {/* Algorithm Menu button */}\r\n            {/* <AlgorithmMenu\r\n            handler={props.handler}\r\n            variant=\"contained\"\r\n            title=\"Select an algorithm\"\r\n          ></AlgorithmMenu> */}\r\n          </Toolbar>\r\n        </AppBar>\r\n      </HideOnScroll>\r\n    </div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport List from \"@material-ui/core/List\";\r\nimport ListItem from \"@material-ui/core/ListItem\";\r\nimport ListItemText from \"@material-ui/core/ListItemText\";\r\nimport MenuItem from \"@material-ui/core/MenuItem\";\r\nimport Menu from \"@material-ui/core/Menu\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    \"&:focus\": {\r\n      backgroundColor: theme.palette.primary.main,\r\n      \"& .MuiListItemIcon-root, & .MuiListItemText-primary\": {\r\n        color: theme.palette.common.white,\r\n      },\r\n    },\r\n  },\r\n}));\r\n\r\nconst options = [\"Slow Speed\", \"Medium Speed\", \"Fast Speed\"];\r\n\r\nexport default function SimpleListMenu(props) {\r\n  const classes = useStyles();\r\n  const [anchorEl, setAnchorEl] = React.useState(null);\r\n  const [selectedIndex, setSelectedIndex] = React.useState(1);\r\n\r\n  const handleClickListItem = (event) => {\r\n    setAnchorEl(event.currentTarget);\r\n  };\r\n\r\n  const handleMenuItemClick = (event, index, newSpeed) => {\r\n    const handler = props.handler;\r\n    handler(newSpeed);\r\n    setSelectedIndex(index);\r\n    setAnchorEl(null);\r\n  };\r\n\r\n  const handleClose = () => {\r\n    setAnchorEl(null);\r\n  };\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <List component=\"nav\" aria-label=\"Device settings\">\r\n        <ListItem\r\n          button\r\n          aria-haspopup=\"true\"\r\n          aria-controls=\"lock-menu\"\r\n          aria-label=\"when device is locked\"\r\n          onClick={handleClickListItem}\r\n          variant=\"contained\"\r\n          color=\"inherited\"\r\n        >\r\n          <ListItemText\r\n            primary=\"Change Speed\"\r\n            secondary={options[selectedIndex]}\r\n          />\r\n        </ListItem>\r\n      </List>\r\n      <Menu\r\n        id=\"lock-menu\"\r\n        anchorEl={anchorEl}\r\n        keepMounted\r\n        open={Boolean(anchorEl)}\r\n        onClose={handleClose}\r\n      >\r\n        {options.map((option, index) => (\r\n          <MenuItem\r\n            key={option}\r\n            selected={index === selectedIndex}\r\n            onClick={(event) => handleMenuItemClick(event, index, index)}\r\n          >\r\n            {option}\r\n          </MenuItem>\r\n        ))}\r\n      </Menu>\r\n    </div>\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nimport InformationBar from \"./InformationBar/InformationBar\";\r\nimport { Button, Toolbar } from \"@material-ui/core\";\r\nimport Dijkstra from \"../Algorithms/Dijkstra.js\";\r\nimport AlgorithmMenu from \"./AlgorithmMenu/AlgorithmMenu\";\r\nimport Grid from \"./Grid/Grid\";\r\nimport TopBar from \"./TopBar/TopBar\";\r\nimport SpeedMenu from \"./SpeedMenu/SpeedMenu\";\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  //constructor for the app, this class is an aggregate for all the different components and serves as the communicator between all the different classes\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      algorithm: new Dijkstra(),\r\n      speed: 1,\r\n    };\r\n    //bind this in the method changeAlgorithm to the current instance of the PathfindingVisualizer\r\n    this.algorithmChangeHandler = this.changeAlgorithm.bind(this);\r\n    this.speedChangeHandler = this.changeSpeed.bind(this);\r\n  }\r\n\r\n  render() {\r\n    const algorithm = this.state.algorithm;\r\n    const speed = this.state.speed;\r\n\r\n    return (\r\n      <div className=\"app\">\r\n        {/* Make a top bar element */}\r\n        <TopBar text={\"Pathfinding Algorithm Visualizer\"}></TopBar>\r\n\r\n        {/* Make Information bar element */}\r\n        <InformationBar></InformationBar>\r\n\r\n        {/* Different buttons*/}\r\n        <Toolbar>\r\n          {/* Select an algorithm menu */}\r\n          <AlgorithmMenu\r\n            handler={this.algorithmChangeHandler}\r\n            variant=\"contained\"\r\n            title=\"Select an algorithm\"\r\n          ></AlgorithmMenu>\r\n          {/* Solve the problem button */}\r\n          <Button\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n            onClick={() => this.clickChild()}\r\n          >\r\n            Visualize {algorithm.getAlgorithmName()}\r\n          </Button>\r\n          {/* Select the speed menu */}\r\n          <SpeedMenu\r\n            handler={this.speedChangeHandler}\r\n            variant=\"contained\"\r\n            title=\"Change Speeds\"\r\n          ></SpeedMenu>\r\n        </Toolbar>\r\n        {/* A sentence describing the algorithm */}\r\n        <div className=\"algorithm-description\">\r\n          {algorithm.getAlgorithmDescription()}\r\n        </div>\r\n\r\n        {/* The grid */}\r\n        <Grid\r\n          algorithm={algorithm}\r\n          setClick={(click) => (this.clickChild = click)}\r\n          changeAlgorithm={this.changeAlgorithm}\r\n          changeSpeed={this.changeSpeed}\r\n          speed={speed}\r\n        ></Grid>\r\n        {/* Some credits */}\r\n        <div className=\"BottomBox\">\r\n          <p>\r\n            This React app was created by{\" \"}\r\n            <a\r\n              href=\"https://www.linkedin.com/in/james-b-ting/\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              James Ting\r\n            </a>{\" \"}\r\n            as a personal project to learn React and JavaScript. Check out the\r\n            source code on{\" \"}\r\n            <a\r\n              href=\"https://github.com/jamesbting/Pathfinding-Algorithm-Visualizer\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              Github\r\n            </a>\r\n            .\r\n          </p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  //function that changes the algorithm\r\n  changeAlgorithm(newAlgorithm) {\r\n    this.setState({ algorithm: newAlgorithm });\r\n  }\r\n\r\n  changeSpeed(newSpeed) {\r\n    this.setState({ speed: newSpeed });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport PathfindingVisualizer from \"./Components/PathfindingVisualizer\";\r\n\r\nfunction App() {\r\n  // store everything  other files, as to not break any of the autogenerated files\r\n  return (\r\n    <div className=\"App\">\r\n      <PathfindingVisualizer></PathfindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}